#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

// 이진 트리의 표현을 연결리스트로 해보자.

// 단순 이중 연결 리스트 이용하기.

typedef int btdata;
typedef struct binaryTreeNode
{
    btdata data;
    struct binaryTreeNode *left, *right;
} btTree;

// 이렇게 해도 되고 아예 binaryTreeNode라는 구조체를 포인터화 해서 사용해도 된다.

typedef struct binaryTreeNode *treePointer;
typedef struct binaryTreeNode
{
    int data;
    treePointer leftChild, rightChild;
} btNode;

// 이렇게 하면 구조체안에 포인터를 사용하지 않아도 바로바로 가능하다.

/* 들어간 순서에 상관없이 ㅜ선순위를 근거로 dequeue연산이 진행된다. 이때 삽입 후에도 주어진 우선순위 데이터 구조를 유지해야한다.

구현 방법에는 크게 세가지가 있다.

    1. 배열
    2. 연결리스트
    3. 힙

1,2로 구현하는 것은 우선 순위를 근거로 데이터의 위치를 찾기 위해서 모든 데이터와 비교를 해야해서 정말 비효율적이다.
그래서 여기선 힙으로 구현한다!.

힙이뭐지?
-> 힙은 이진 트리 기반의 데이터 구조다. 각 노드의 값이 대소 비교를 만족하는 완전 이진 트리임.
(부모 노드 < 자식 노드 or 부모 노드 > 자식 노드)을 만족하는 완전 이진 트리다.

힙은 두가지로 분류 된다.

    1. 최대 힙.
    -> 모든 부모 노드의 값이 해당 자식 노드의 값보다 크거나, 같은 완전 이진 트리.
    즉, 이렇게 하면 루트노드가 제일 큰 값을 가진다.

    2. 최소 힙
    -> 모든 부모 노드의 값이 해당 자식 노드의 값보다 작거나 같은 완전 이진 트리.
    즉, 트리의 루트 노드가 가장 작은 값을 가짐.


힙 연산은 삽입과 삭제가 이뤄진다.
    - 삽입 : 원소를 새롭게 추가하고, 힙 구조를 유지하면서 적절한 위치에 노드를 배치한다.
    - 삭제 : 보통 최소 힙에서는 최솟값을, 최대 힙에서는 최댓값을 삭제한다. 삭제 후에도 힙 구조를 유지해야한다.

힙으로 뭘 할 수 있나?

    1. 우선순위 큐 구현 : 원소들 간의 우선순위를 고려해서 효율적으로 최소, 최대 값 추출 가능.
    2. 힙 정렬 : 힙의 특성을 사용한 정렬 알고리즘으로 빠른 정렬 가능.

*/

// 힙 구현해보기
// 1차원 배열을 이용하면 인덱스 관꼐를 이용해서 부모 노드를 찾기가 쉽다. 
typedef int Hdata;
typedef struct {
    Hdata heap[MAX_SIZE];  // 아마 오류가 나겠지만 일단은 무시한다.
    int numOfData;
}heap;  

// 힙 삽입 알고리즘
void insertHeap(heap* h, Hdata x) {
    if(h->numOfData == MAX_SIZE) {  // 일단 힙의 전체 크기가 최대 크기와 같으면 overflow 출력하기. (함수 종료) 
        printf("Overflow\n");
        return; 
    }

/* 새로운 삽입 위치를결정하기 위해 idx라는 이름의 인덱스 변수를 만들고 현재 데이터 개수에 +1을 더한 값을 저장한다. 
 이렇게 하면 배열에 빈 공간이 생겨 새로운 데이터를 삽입할 위치가 확보된다. 
이렇게 왜 +1을 한 이유는 먼저, 최대 힙을 배열로 구현할 때 배열 인덱스는 1부터 시작해서 그렇다. 그러면 루트 노드가 배열의 첫 번째 요소에 (인덱스 0이아닌 1)에 저장된다. 
완전 이진 트리 특성상 다음 레벨의 노드는 순차적으로 왼쪽에서 오른쪽으로 배열에 추가된다.


"현재 데이터 개수 + 1" -> 새 데이터를 완전 이진 트리의 다음 노드 위치에 빈 공간으로 확보하기 위해서 이렇게 했다. 
즉, 마지막 노드의 바로 다음 위치에 새로운 데이터를 먼저 삽입하게 된다. 이렇게 하면 힙이 완전 이진 트리로 유지 되고
이후 부모 노드와의 대소 관계에 따라 오른쪽으로 가던 왼쪽으로 가던 한다. 

ex: 현재 힙의 데이터 개수가 5인 경우, 완전 이진 트리의 마지막 노드는 배열의 인덱스 5에 위치한다. 
*/
    int idx = h->numOfData + 1; 

    while(idx != 1) { 
        /* while 조건은 "삽입하려는 데이터의 위치가 최대 힙의 루트노드에 도달하지 않았는지" 확인하는 것이다. 
        이때 최대 힙의 루트 노드의 인덱스는 1이다. 
        
        여기서 반복문은 새로 삽입된 데이터가 최대 힙의 특성을 만족할때 까지 상위 노드와의 위치를 변경하는 작업을 수행하는데. 
        즉, 새 데이터가 부모 노드보다 크면 자리를 바꾸는 작업을 반복한다. 그리고 더 이상 부모 노드 보다 큰 값이 없을 때 까지 
        이 작업이 반복된다. 
        
        여기서 루트 노드(인덱스 1)는 트리의 가장 상위 노드이고 부모노드가 없어서 이미 루트 노드 위치에 도달한 경우, 자리 변경을 더 이상할 할 필요가 없다. 

        쉽게 말하면 idx가 1이 될때 종료한다는 것이고 이 뜻은 새로 삽입한 데이터가. 최 상위 노드가 됐을때 종료한다는 말이다. 
        */

       /* heap[idx/2]: 현재 위치한 노드의 부모 노드를 가리키고 있다.
       idx/2라는 표현이 부모노드를 가르키고 있다고 이해하자. 최대 힙은 완전 이진 트리니까 여기서 주어진 인덱스(i)에 대한 부모노드는 idx/2로 구할 수 있다. 
       여기서 h는 최대 힙 구조체 포인터고 해당 배열(heap)에 접근해서 부모 노드 위치의 값을 가져온다. 
       
       2. 아래 조건문은 새로 삽입된 데이터 x를 현재 노드의 부모노드와 비교하는 것이다. 
       이때 x가 부모노드보다 크다면 최대힙의 특성을 유지하기 위해 자리 바꿔야한다. 
       (위치 순서는 왼쪽 < 부모 < 오른쪽 순)
       
       3. h->heap[idx] = h->heap[idx/2];
       조건이 참일경우 (새 데이터가 부모노드보다 클 경우), 부모 노드의 값을 현재 노드 위치로 가져오고
       부모 노드 위치로 올라간다. (부모노드를 내리고 자기가 올라간다) 여기서 아직 새 데이터의 자리는 변경되지 않았다. 

       4. idx = idx/2; 
       부모 노드의 인덱스를 새로운 현재 인덱스로 업데이트한다. 이 과정으로 계속 상위 레벨로 올라가고 부모 노드와의 값을 비교 할 수 있다. 

       */
        if(x > h->heap[idx / 2]) {
            h->heap[idx] = h->heap[idx/2];
            idx = idx/2;
        }
        else {
            break;
        }
    }
/* 1. h->heap[idx] = x : 새 데이터의 최종 위치가 결정되었고, 이제 해당 인덱스에 새 데이터 x값을 할당한다. 
이 작업으로 최초에 비어있던 공간에 새 데이터가 삽입되며 최대 힙의 특성이 유지된다. 

2. ++부분 : 새로운 데이터가 힙에 추가된 것을 반영하기 위해 데이터 개수를 1 증가 시킨것이다. */
    h->heap[idx] = x;
    h->numOfData++;
}



