#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

// 이진 트리의 표현을 연결리스트로 해보자.

// 단순 이중 연결 리스트 이용하기.

typedef int btdata;
typedef struct binaryTreeNode
{
    btdata data;
    struct binaryTreeNode *left, *right;
} btTree;

// 이렇게 해도 되고 아예 binaryTreeNode라는 구조체를 포인터화 해서 사용해도 된다.

typedef struct binaryTreeNode *treePointer;
typedef struct binaryTreeNode
{
    int data;
    treePointer leftChild, rightChild;
} btNode;

// 이렇게 하면 구조체안에 포인터를 사용하지 않아도 바로바로 가능하다.

/* 들어간 순서에 상관없이 ㅜ선순위를 근거로 dequeue연산이 진행된다. 이때 삽입 후에도 주어진 우선순위 데이터 구조를 유지해야한다.

구현 방법에는 크게 세가지가 있다.

    1. 배열
    2. 연결리스트
    3. 힙

1,2로 구현하는 것은 우선 순위를 근거로 데이터의 위치를 찾기 위해서 모든 데이터와 비교를 해야해서 정말 비효율적이다.
그래서 여기선 힙으로 구현한다!.

힙이뭐지?
-> 힙은 이진 트리 기반의 데이터 구조다. 각 노드의 값이 대소 비교를 만족하는 완전 이진 트리임.
(부모 노드 < 자식 노드 or 부모 노드 > 자식 노드)을 만족하는 완전 이진 트리다.

힙은 두가지로 분류 된다.

    1. 최대 힙.
    -> 모든 부모 노드의 값이 해당 자식 노드의 값보다 크거나, 같은 완전 이진 트리.
    즉, 이렇게 하면 루트노드가 제일 큰 값을 가진다.

    2. 최소 힙
    -> 모든 부모 노드의 값이 해당 자식 노드의 값보다 작거나 같은 완전 이진 트리.
    즉, 트리의 루트 노드가 가장 작은 값을 가짐.


힙 연산은 삽입과 삭제가 이뤄진다.
    - 삽입 : 원소를 새롭게 추가하고, 힙 구조를 유지하면서 적절한 위치에 노드를 배치한다.
    - 삭제 : 보통 최소 힙에서는 최솟값을, 최대 힙에서는 최댓값을 삭제한다. 삭제 후에도 힙 구조를 유지해야한다.

힙으로 뭘 할 수 있나?

    1. 우선순위 큐 구현 : 원소들 간의 우선순위를 고려해서 효율적으로 최소, 최대 값 추출 가능.
    2. 힙 정렬 : 힙의 특성을 사용한 정렬 알고리즘으로 빠른 정렬 가능.

*/

// 힙 구현해보기
// 1차원 배열을 이용하면 인덱스 관꼐를 이용해서 부모 노드를 찾기가 쉽다. 
typedef int Hdata;
typedef struct {
    Hdata heap[MAX_SIZE];  // 아마 오류가 나겠지만 일단은 무시한다.
    int numOfData;
}heap;  

// 힙 삽입 알고리즘
void insertHeap(heap* h, Hdata x) {
    if(h->numOfData == MAX_SIZE) {  // 일단 힙의 전체 크기가 최대 크기와 같으면 overflow 출력하기. (함수 종료) 
        printf("Overflow\n");
        return; 
    }

/* 새로운 삽입 위치를결정하기 위해 idx라는 이름의 인덱스 변수를 만들고 현재 데이터 개수에 +1을 더한 값을 저장한다. 
 이렇게 하면 배열에 빈 공간이 생겨 새로운 데이터를 삽입할 위치가 확보된다. 
이렇게 왜 +1을 한 이유는 먼저, 최대 힙을 배열로 구현할 때 배열 인덱스는 1부터 시작해서 그렇다. 그러면 루트 노드가 배열의 첫 번째 요소에 (인덱스 0이아닌 1)에 저장된다. 
완전 이진 트리 특성상 다음 레벨의 노드는 순차적으로 왼쪽에서 오른쪽으로 배열에 추가된다.


"현재 데이터 개수 + 1" -> 새 데이터를 완전 이진 트리의 다음 노드 위치에 빈 공간으로 확보하기 위해서 이렇게 했다. 
즉, 마지막 노드의 바로 다음 위치에 새로운 데이터를 먼저 삽입하게 된다. 이렇게 하면 힙이 완전 이진 트리로 유지 되고
이후 부모 노드와의 대소 관계에 따라 오른쪽으로 가던 왼쪽으로 가던 한다. 

ex: 현재 힙의 데이터 개수가 5인 경우, 완전 이진 트리의 마지막 노드는 배열의 인덱스 5에 위치한다. 
*/
    int idx = h->numOfData + 1; 

    while(idx != 1) { 
        /* while 조건은 "삽입하려는 데이터의 위치가 최대 힙의 루트노드에 도달하지 않았는지" 확인하는 것이다. 
        이때 최대 힙의 루트 노드의 인덱스는 1이다. 
        
        여기서 반복문은 새로 삽입된 데이터가 최대 힙의 특성을 만족할때 까지 상위 노드와의 위치를 변경하는 작업을 수행하는데. 
        즉, 새 데이터가 부모 노드보다 크면 자리를 바꾸는 작업을 반복한다. 그리고 더 이상 부모 노드 보다 큰 값이 없을 때 까지 
        이 작업이 반복된다. 
        
        여기서 루트 노드(인덱스 1)는 트리의 가장 상위 노드이고 부모노드가 없어서 이미 루트 노드 위치에 도달한 경우, 자리 변경을 더 이상할 할 필요가 없다. 

        쉽게 말하면 idx가 1이 될때 종료한다는 것이고 이 뜻은 새로 삽입한 데이터가. 최 상위 노드가 됐을때 종료한다는 말이다. 
        */

       /* heap[idx/2]: 현재 위치한 노드의 부모 노드를 가리키고 있다.
       idx/2라는 표현이 부모노드를 가르키고 있다고 이해하자. 최대 힙은 완전 이진 트리니까 여기서 주어진 인덱스(i)에 대한 부모노드는 idx/2로 구할 수 있다. 
       여기서 h는 최대 힙 구조체 포인터고 해당 배열(heap)에 접근해서 부모 노드 위치의 값을 가져온다. 
       
       2. 아래 조건문은 새로 삽입된 데이터 x를 현재 노드의 부모노드와 비교하는 것이다. 
       이때 x가 부모노드보다 크다면 최대힙의 특성을 유지하기 위해 자리 바꿔야한다. 
       (위치 순서는 왼쪽 < 부모 < 오른쪽 순)
       
       3. h->heap[idx] = h->heap[idx/2];
       조건이 참일경우 (새 데이터가 부모노드보다 클 경우), 부모 노드의 값을 현재 노드 위치로 가져오고
       부모 노드 위치로 올라간다. (부모노드를 내리고 자기가 올라간다) 여기서 아직 새 데이터의 자리는 변경되지 않았다. 

       4. idx = idx/2; 
       부모 노드의 인덱스를 새로운 현재 인덱스로 업데이트한다. 이 과정으로 계속 상위 레벨로 올라가고 부모 노드와의 값을 비교 할 수 있다. 

       */
        if(x > h->heap[idx / 2]) {
            h->heap[idx] = h->heap[idx/2];
            idx = idx/2;
        }
        else {
            break;
        }
    }
/* 1. h->heap[idx] = x : 새 데이터의 최종 위치가 결정되었고, 이제 해당 인덱스에 새 데이터 x값을 할당한다. 
이 작업으로 최초에 비어있던 공간에 새 데이터가 삽입되며 최대 힙의 특성이 유지된다. 

2. ++부분 : 새로운 데이터가 힙에 추가된 것을 반영하기 위해 데이터 개수를 1 증가 시킨것이다. */
    h->heap[idx] = x;
    h->numOfData++;
}


// 삭제 함수 구현
/** 삭제함수는 무조건 루트노트를 삭제하게 되어있다. 
 * 루트 노드가 빠져버린다면 모양이 이상하니까 뭘 하나 가져다 놔야한다. 그럼 뭘 가져다 놔야할까? 
 * 먼저 노드 번호를 매겼다고 가정했을때 가장 큰 번호 노드를 루트노드로 가져온다. (이 말은 가장 아래에 있는 노드로 바꾸고 만약 다 레벨이 동일하면 가장 오른쪽에 있는 노드를 선택)
 * 이 과정까지 오면 일단 완전 이진 트리의 구조를 가지지만 max heap을 가지지는 않았을 것이다. 
 * 그래서 바꾼 부모노드를 위에서 아래로 비교하면서 서로 위치를 바꿔주면 된다. 
 * 그런데 자식 입장에서 부모 노드 하나만 비교했으면 됐었지만 지금은 부모 입장에서 많은 자식과 비교해야 하니 벌써 머리가 아프다. 
 * 즉 두개의 자식을 비교해서 더 큰 값으로 바꿔야한다. 
 * 자리를 바꿨으면 그 자리에 있는 자식과 비교해야한다. 만약 비교해서 자신이 더 크다면 끝이고 더 작다면 또 바꾼다. 
 * 
 * 
 * 이제 구현해보자. 
 * 노드를 삭제할때 무조건 루트 노드가 삭제되니 몇번 노드를 삭제해라 이런건 필요가 없다. 
 * 그리고 반환 타입은 int이고 인자는 heap에 대한 포인터만 주면 된다. 
 * 구현 전에 예외 처리를 하자. 
*/


int deleteHeap(heap *h) {

    // heap이 비었을때 예외처리 했다. 
    if(h->numOfData == 0) {
        printf("비었습니다.\n");
        return -1;
    }

    // 이제 반환할 데이터를 미리 다른 지역변수에 빼서 담아두자. 
    // 루트 노드는 1번에 있으니 이렇게 담아뒀다. 그리고 연산이 끝나면 이 topData를 반환하면 된다. 
    int topData = h->heap[1]; 

    // 그리고 값하고는 상관없이 일단 완전이진트리의 구조를 유지하는 것이 목적이다. 
    // 이제 루트 노드에다가 맨 마지막에 있는 노드 내용을 옮겨 주고 유효한 원소 개수를 하나 줄여주면 된다. 
    //  h->heap[h->numOfdata] 이 코드가 맨 마지막 노드 내용이 되는 이유는? 
    // numOfData자체가 heap배열 안에 있는 데이터 개수를 뜻하고 그 개수를 인덱스화 시키면 맨 마지막 데이터가 되서 그렇다. 
    // 즉 h->numOfData가 맨 마지막 노드 내용을 가르킨다. 
    // 예를 들어 {1,2,3,4,5,6}이라는 배열이 있다고 하면 이것의 h->numOfData = 6이된다. 
    // h->heap[6]이 되어 결과적으로 맨 마지막 노드 내용인 1이 된다. 
     h->heap[1] = h->heap[h->numOfdata];

     // 유효한 노드 개수를 하나 줄이는 이유. 
     // 이미 해당 값을 루트 노드로 옮겼기 때문에 중복되어 저장되지 않게 하기 위해서다. 
     // 즉, 마지막 노드를 삭제하는 것이 아니라 가장 마지막 노드의 데이터를 루트노드로 이동한 후에 
     // 실제로는 더 이상 처리할 필요가 없는 마지막 노드를 표시하는 힙 크기를 줄이는 것. 
     h->numOfData--;

    // 이것으로써 완전이진트리의 구조를 지켜냈다. 

/** 이제 1번 노드를 기준으로 위에서 아래로 내려가면서 값을 비교해 가며 자리를 바꿔주는 코드를 작성해야한다. 
 * current 노드 자리와 비교할 자식 노드 자리를 만들어 주자
*/

int cur, child;


/** 현재 노드를 루트 노드로 했다.
 * 왼쪽 노드를 구하려면 부모노드 인덱스에 *2를 하면 나온디.
 * 그리고 마지막 노드 값이랑 비교해서 왼쪽 자식 노드가 있는지 검사한다. 
 * <= 라면 왼쪽 자식 노드가 있는 것이므로 반복문을 돌릴 것이다. 
 * 왜냐면 최대 힙에서 왼쪽 자식 노드는 부모 노드와 같거나 작으면 존재한다고 한다. 
 * 반대로 오른쪽 노드는 부모노드와 같거나 커야 존재한다고 한다.
 * 그러니 자식노드와 비교할 것이 있으니 밑으로 내려간다.  
*/
cur = 1; // 현재 노드를 루트노드로 했다. 
while ((cur*2) <= h->numOfData)
    
}